To create a basic RESTful API for managing a book inventory, you can follow these steps using **Python** with the **Flask** framework and **SQLite** for the database. Flask is lightweight and easy to get started with for building APIs, while SQLite is a simple, file-based relational database that works well for this kind of task.

### Step 1: Install the required packages
You need to install Flask and Flask-SQLAlchemy (for database ORM) if you haven't already:

```bash
pip install Flask Flask-SQLAlchemy
```

### Step 2: Setting up the Flask app and SQLite database
We'll create the main file for the API (`app.py`), which will define the API routes and connect to an SQLite database.

```python
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy

# Initialize Flask app and database
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///books.db'  # SQLite database file
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Define the Book model
class Book(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    author = db.Column(db.String(100), nullable=False)
    genre = db.Column(db.String(50), nullable=False)
    published_year = db.Column(db.Integer, nullable=False)

    def __repr__(self):
        return f"<Book {self.title}>"

# Create the database tables
with app.app_context():
    db.create_all()

# Route to add a new book
@app.route('/books', methods=['POST'])
def add_book():
    data = request.get_json()
    new_book = Book(
        title=data['title'],
        author=data['author'],
        genre=data['genre'],
        published_year=data['published_year']
    )
    db.session.add(new_book)
    db.session.commit()
    return jsonify({'message': 'Book added successfully!'}), 201

# Route to list all books
@app.route('/books', methods=['GET'])
def get_books():
    books = Book.query.all()
    books_list = [
        {
            'id': book.id,
            'title': book.title,
            'author': book.author,
            'genre': book.genre,
            'published_year': book.published_year
        }
        for book in books
    ]
    return jsonify({'books': books_list})

# Route to get a specific book by ID
@app.route('/books/<int:id>', methods=['GET'])
def get_book(id):
    book = Book.query.get_or_404(id)
    return jsonify({
        'id': book.id,
        'title': book.title,
        'author': book.author,
        'genre': book.genre,
        'published_year': book.published_year
    })

# Route to update a book's details
@app.route('/books/<int:id>', methods=['PUT'])
def update_book(id):
    book = Book.query.get_or_404(id)
    data = request.get_json()
    
    book.title = data.get('title', book.title)
    book.author = data.get('author', book.author)
    book.genre = data.get('genre', book.genre)
    book.published_year = data.get('published_year', book.published_year)

    db.session.commit()
    return jsonify({'message': 'Book updated successfully!'})

# Route to delete a book
@app.route('/books/<int:id>', methods=['DELETE'])
def delete_book(id):
    book = Book.query.get_or_404(id)
    db.session.delete(book)
    db.session.commit()
    return jsonify({'message': 'Book deleted successfully!'})

# Run the app
if __name__ == '__main__':
    app.run(debug=True)
```

### Explanation of the Code:

1. **Flask App Setup**:
   - `Flask`: The main framework to create the API.
   - `Flask-SQLAlchemy`: An ORM to interact with the database in a Pythonic way.
   - `SQLALCHEMY_DATABASE_URI`: Specifies the SQLite database location.
   - `db.create_all()`: Initializes the database and creates the necessary tables.

2. **Book Model**:
   - A class `Book` defines the database model with fields for `id`, `title`, `author`, `genre`, and `published_year`. The `id` field is the primary key.

3. **API Routes**:
   - `POST /books`: Adds a new book to the inventory.
   - `GET /books`: Lists all books in the inventory.
   - `GET /books/<int:id>`: Retrieves a single book by its ID.
   - `PUT /books/<int:id>`: Updates the details of an existing book.
   - `DELETE /books/<int:id>`: Deletes a book by its ID.

4. **JSON Responses**:
   - Every route returns a `jsonify` response, which turns Python dictionaries into JSON.

### Step 3: Run the Application

To run the application, use the following command in your terminal:

```bash
python app.py
```

This will start the Flask development server. You can access your API by sending HTTP requests to:

- `http://127.0.0.1:5000/books` (for listing or adding books)
- `http://127.0.0.1:5000/books/<id>` (for getting, updating, or deleting a specific book)

### Step 4: Example API Requests

1. **Add a book (POST)**:
   ```bash
   curl -X POST http://127.0.0.1:5000/books \
   -H "Content-Type: application/json" \
   -d '{"title": "1984", "author": "George Orwell", "genre": "Dystopian", "published_year": 1949}'
   ```

2. **List all books (GET)**:
   ```bash
   curl http://127.0.0.1:5000/books
   ```

3. **Get a specific book (GET by ID)**:
   ```bash
   curl http://127.0.0.1:5000/books/1
   ```

4. **Update a book (PUT)**:
   ```bash
   curl -X PUT http://127.0.0.1:5000/books/1 \
   -H "Content-Type: application/json" \
   -d '{"title": "1984 (Updated)", "author": "George Orwell", "genre": "Dystopian", "published_year": 1949}'
   ```

5. **Delete a book (DELETE)**:
   ```bash
   curl -X DELETE http://127.0.0.1:5000/books/1
   ```

### Conclusion

This is a simple RESTful API to manage a book inventory. You can extend it further by adding user authentication, pagination, or validation of the input data. This basic setup will help you manage your books by adding, listing, deleting, and updating them using a RESTful approach.
